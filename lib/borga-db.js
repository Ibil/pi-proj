'use strict'

const fetch = require('node-fetch')
const crypto = require('crypto');

const BONSAI_ELASTIC_HOST = process.env.BONSAI_URL
const ELASTIC_HOST = BONSAI_ELASTIC_HOST ? BONSAI_ELASTIC_HOST + '\\' : 'http://localhost:9200/'
const USERS_INDEX = 'users/';
const GROUPS_INDEX = 'groups/';
const GET_ALL_DOCS = '_search?size=1000';
const DOC = '_doc/';


module.exports = {
    insertDummyUser,
    insertUser,
    getAllUsers,
    getAllGroups,
    getGroup,
    insertGroup,
    updateGroup,
    deleteGroup,
    insertGame,
    deleteGame
}


/**
 * @typedef User
 * @type {Object}
 * @property {String} bearerToken Unique random id
 * @property {String} userName
* @property {String} password
 * 
 */


/**
 * Creates a User
 * @returns {Promise.<String>} Promise with user Bearer Token
 */
function insertUser(userName, password) {
    const user = {
        userName: userName,
        password: password,
        bearerToken: crypto.randomUUID()
    }
    return fetch(ELASTIC_HOST + USERS_INDEX + DOC + '?refresh=true', {
        method: 'post',
        body: JSON.stringify(user),
        headers: { 'Content-Type': 'application/json' },
    })
        .then(res => { if (checkStatus(res, 201)) return res.json() }) // TODO else reject promise 500 at service
        .then(doc => {
            return user.bearerToken;
        })
}

function insertDummyUser() {
    const user = {
        userName: "Test",
        password: "34428d8e4ab7298a22dcb907e049bd4671c6fd6e5d6f3dd6a51338f638b6db6a", // cyphered "gamboa"
        bearerToken: "8ab8dd96-4c74-4c91-be3d-f8011d92f1ff"
    }
    return fetch(ELASTIC_HOST + USERS_INDEX + DOC + '?refresh=true', {
        method: 'post',
        body: JSON.stringify(user),
        headers: { 'Content-Type': 'application/json' },
    })
        .then(res => { if (checkStatus(res, 201)) return res.json() }) // TODO else reject promise 500 at service
        .then(doc => {
            return user.bearerToken;
        })
}


/**
 * @returns {Promise.<Array.<User>>}
 */
 function getAllUsers() {
    return fetch(ELASTIC_HOST + USERS_INDEX + GET_ALL_DOCS)
        .then(res => { if (checkStatus(res, 200)) return res.json() }) // TODO else reject promise 500 at service
        .then(doc => doc.hits.hits.map(d => {
            return {
                bearerToken: d._source.bearerToken,
                userName: d._source.userName,
                password: d._source.password
            }
        }))
}

//#region group index

/**
 * @typedef Group
 * @type {Object}
 * @property {String} id Unique id based on the _id generated by ElasticSearch.
 * @property {String} bearerToken
 * @property {String} name
 * @property {String} description 
 * @property {Array<Group>} games 
 * 
 */

/**
 * @returns {Promise.<Array.<Group>>}
 */
function getAllGroups() {
    return fetch(ELASTIC_HOST + GROUPS_INDEX + GET_ALL_DOCS)
        .then(res => { if (checkStatus(res, 200)) return res.json() }) // TODO else reject promise 500 at service
        .then(doc => doc.hits.hits.map(d => {
            return {
                id: d._id,
                bearerToken: d._source.bearerToken,
                name: d._source.name,
                description: d._source.description,
                games: d._source.games
            }
        }))
}

/**
 * @param {String} elasticId 
 * @param {String} bearerToken 
 * @returns {Promise.<Group>}
 */
function getGroup(bearerToken, elasticId) {
    return fetch(ELASTIC_HOST + GROUPS_INDEX + DOC + elasticId)
        .then(res => { if (checkStatus(res, 200, 'No group with id ' + elasticId)) return res.json() }) // TODO handle errors
        .then(doc => {
            if (doc._source.bearerToken != bearerToken)
                throw taskError(404, "group not found for this user")
            doc._source.id = doc._id
            return doc._source
        })
}

/** 
* @param {String} bearerToken 
* @param {String} name
* @param {String} description 
* @returns {Group} New Group object.
*/
function newGroup(bearerToken, name, description) {
    return {
        bearerToken: bearerToken,
        name: name,
        description: description,
        games: []
    }
}

/**
 * @param {String} bearerToken
 * @param {String} name 
 * @param {String} description
 * @returns {Promise.<String>} fulfills with the ne group id
 */
function insertGroup(bearerToken, name, description) {
    const group = newGroup(bearerToken, name, description)
    return fetch(ELASTIC_HOST + GROUPS_INDEX + DOC + '?refresh=true', {
        method: 'post',
        body: JSON.stringify(group),
        headers: { 'Content-Type': 'application/json' },
    })
        .then(res => { if (checkStatus(res, 201)) return res.json() }) // handle errors
        .then(doc => {
            return doc._id;
        })
}

/**
 * @param {String} elasticId 
 * @param {String} bearerToken
 * @param {String} name 
 * @param {String} description
 * @returns {Promise.<String>} Fulfills with the new Group after save on Elastic.
 */
function updateGroup(elasticId, name, description, bearerToken) {
    return getGroup(bearerToken, elasticId) // TODO handle errors
        .then(group => {
            group.name = name;
            group.description = description;
            return fetch(ELASTIC_HOST + GROUPS_INDEX + DOC + elasticId + '?refresh=true', {
                method: 'put',
                body: JSON.stringify(group),
                headers: { 'Content-Type': 'application/json' },
            })
                .then(res => {
                    if (checkStatus(res, 200)) {
                        return res.json()
                    }
                }) // todo handle errors
                .then(doc => doc._id);
        })
}

function deleteGroup(elasticId, bearerToken) {
    return getGroup(bearerToken, elasticId)
    .then(group =>{
        return fetch(ELASTIC_HOST + GROUPS_INDEX + DOC + elasticId + '?refresh=true', {
            method: 'delete'
        })
            .then(res => { checkStatus(res, 200)}) // TODO handle errors
    })   
}

// games
/**
 * @typedef Game
 * @type {Object}
 * @property {String} gameId
 * @property {String} gameName 
 * 
 */

/** 
* @param {String} gameId 
* @param {String} gameName
* @returns {Group} New Game object.
*/
function newGame(gameId, gameName) {
    return {
        gameId: gameId,
        gameName: gameName
    }
}

/**
 * @param {String} bearerToken
 * @param {String} name 
 * @param {String} description
 * @returns {Promise.<String>} ok
 */
function insertGame(groupId, gameId, gameName, bearerToken) {
    return getGroup(bearerToken, groupId)
        .then(group => {

            group.games.push(newGame(gameId, gameName))

            // TODO copied code from update group : refactor !! attention this takes groupid AND NOT ELASTICID (which is the same here)
            return fetch(ELASTIC_HOST + GROUPS_INDEX + DOC + groupId + '?refresh=true', {
                method: 'put',
                body: JSON.stringify(group),
                headers: { 'Content-Type': 'application/json' },
            })
                .then(res => {
                    if (checkStatus(res, 200)) {
                        return res.json()
                    }
                }) // todo handle errors
                .then(doc => {});
        });
}

function deleteGame(groupId, gameId, bearerToken) {
    return getGroup(bearerToken, groupId)
    .then(group => {
        const newGameList = group.games.filter(game => game.gameId != gameId);
        if(group.games.length != newGameList.length){
            group.games = newGameList;
        }
        else{
            throw new Error("Could not find the given game in the given group");
        }

        // TODO copied code from update group : refactor !! attention this takes groupid AND NOT ELASTICID (which is the same here)
        return fetch(ELASTIC_HOST + GROUPS_INDEX + DOC + groupId + '?refresh=true', {
            method: 'put',
            body: JSON.stringify(group),
            headers: { 'Content-Type': 'application/json' },
        })
            .then(res => {
                if (checkStatus(res, 200)) {
                    return res.json()
                }
            }) // todo handle errors
            .then(doc => {});
    });
}


//#endregion


//#region   Helper functions
function checkStatus(res, code, msg) {
    if (res.status === code) return true
    const err = msg
        ? Error(msg)
        : Error(res.statusText)
    err.status = res.status
    throw err
}

function taskError(status, message) {
    const err = new Error(message)
    err.status = status
    return err
}

//#endregion